using System.Collections;
using System;
using System.Collections.Generic;
using UnityEngine;
using EvolveGames;
using TMPro;

public class AISpawner : MonoBehaviour
{
    public GameObject aiPrefab;
    public PlayerTeleporter playerTeleporter;
    public float spawnInterval;
    public int[] spawnCountsPerWave = {10,20,30};
    public int maxWaves = 3;
    public int currentWave = 0;
    public int enemyCount = 0;
    public GameObject panel;
    public TextMeshProUGUI teleportText;
    public TextMeshProUGUI teleportoutsideText;
    public AudioSource encounterAudio;
    public AudioSource notencounterAudio;
    public int allowedPrefabCount = 0;
    public Placeblock placeblockScript;
    public PlayerHealth playerHealth;
    
    // Start is called before the first frame update
    void Start()
    {
        StartCoroutine(SpawnAICoroutine());
    }

    IEnumerator SpawnAICoroutine()
    {
        while (currentWave <= spawnCountsPerWave[currentWave])
        {
            
            for(int i = 0;i < spawnCountsPerWave[currentWave]; i++)
            {
                yield return StartCoroutine(SpawnWaveCoroutine(spawnCountsPerWave[currentWave]));
                yield return StartCoroutine(CountdownCoroutine(3));
                encounterAudio.Play();
                notencounterAudio.Stop();
                playerTeleporter.TeleporttoTarget(new Vector3(-4.368393f, 3.837281f, 10.12f));
                currentWave++;
                playerHealth.StartShortinvincibility();
                allowedPrefabCount = currentWave + 1;
                placeblockScript.UpdateStandCountText();
                yield return new WaitUntil(() => enemyCount == 0);
                if(currentWave < maxWaves)
                {
                    encounterAudio.Stop();
                    notencounterAudio.Play();
                    playerTeleporter.TeleporttoTarget(new Vector3(-20.34f, 3.837281f, 45.93f));
                    teleportoutsideText.text = "Wave " + currentWave + " Cleared.Be prepare for next wave.";
                    yield return new WaitForSeconds(3f);
                    teleportoutsideText.text = "";
                    
                }

                if(currentWave == maxWaves)
                {
                    Animator animator = panel.GetComponent<Animator>();
                    encounterAudio.Stop();
                    notencounterAudio.Stop();
                    panel.SetActive(true);
                    Cursor.lockState = CursorLockMode.None;
                    Cursor.visible = true;

                    if (animator != null)
                    {
                        animator.SetBool("GameClearPanel", true);
                        StartCoroutine(WaitForAnimationAndPause(animator));
                    }
                    else
                    {
                        Time.timeScale = 0;
                    }

                }
            }
          
        }
        
    }
   
    IEnumerator CountdownCoroutine(int seconds)
    {
        for(int i = seconds; i > 0; i--)
        {
            teleportText.text = "Teleport in " + i;
            yield return new WaitForSeconds(1f);
        }
        teleportText.text = " ";
    }

    IEnumerator WaitForAnimationAndPause(Animator animator)
    {
        yield return new WaitForSeconds(animator.GetCurrentAnimatorStateInfo(0).length);
        Time.timeScale = 0;
    }


    IEnumerator SpawnWaveCoroutine(int spawnCount)
    {
        int spawnedCount = 0;

        while(spawnedCount < spawnCount)
        {
            SpawnAI();
            spawnedCount++;
            float elapsedTime = 0f;
            while (elapsedTime < spawnInterval)
            {
                elapsedTime += Time.deltaTime;
                yield return null;
            }
        }
    }


    void SpawnAI()
    {
        if(aiPrefab != null)
        {
            Vector3 spawnPosition = transform.position + UnityEngine.Random.insideUnitSphere * 3f;
            GameObject newAI = Instantiate(aiPrefab, spawnPosition, Quaternion.identity);
            newAI.GetComponent<AIDamageHandler>().OnDeath += OnAIDeath;
            enemyCount++;
        }
    }


    void OnAIDeath()
    {
        enemyCount--;
    }

}
